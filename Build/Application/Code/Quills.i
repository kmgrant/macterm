%define DOCSTRING
"The `Quills` module exposes the entire MacTerm API to Python,
allowing you to directly access core functionality from scripts!"
%enddef

%module(docstring=DOCSTRING) quills

%include "exception.i"
%include "stl.i"

// include headers that should *not* be wrapped in Python, but are
// necessary for the implementation code in this file or in files
// that it includes while in SWIG mode
%{
#include <stdexcept>
#include <Console.h>
%}

// Apple’s "AssertMacros.h" contains errant #define macros that corrupt
// C++ code generated by SWIG - see rdar://4700324 for more on this.
// By undefining "check", check()-like methods are not corrupted.
%{
#ifdef check
#undef check
#endif
%}

// forward-declare the generated initializer routine from SWIG to
// suppress an annoying compiler warning
%{
#if PY_VERSION_HEX >= 0x03000000
extern "C" PyObject* PyInit__quills(void);
#else
extern "C" void init_quills(void);
#endif
%}

// instantiate template types relied upon by Quills
%template(_float_list) std::vector< double >;
%template(_long_list) std::vector< long >;
%template(_long_pair) std::pair< long, long >;
%template(_string_list) std::vector< std::string >;
%template(_string_by_long) std::map< long, std::string >;

// enable callbacks to be written in Python
#ifdef SWIGPYTHON
%typemap(in) PyObject* inPythonFunction
{
	if (false == PyCallable_Check($input))
	{
		PyErr_SetString(PyExc_TypeError, "Parameter is not a function");
		return nullptr;
	}
	$1 = $input;
}
#endif

// Python exception-handling utility
#ifdef SWIGPYTHON
%{
/*!
This class helps to make exception messages a bit more descriptive
when the cause of the error is something in a Python callback.

(4.0)
*/
class _Quills_CallbackError: public std::runtime_error
{
public:
	_Quills_CallbackError	(char const*	inMessage,
							 PyObject*		inFunction)
	:
	std::runtime_error(getMessage(inMessage, inFunction))
	{
	}
	
	~_Quills_CallbackError () throw ()
	{
	}

protected:
	std::string
	getMessage	(char const*	inMessage,
				 PyObject*		inFunction)
	const
	{
		std::string		result(inMessage);
		
		
		if ((nullptr != inFunction) && (nullptr != PyEval_GetFuncName(inFunction)))
		{
			result += "; while calling ";
			result += PyEval_GetFuncName(inFunction);
			result += "()";
		}
		return result;
	}

private:
};


/*!
Utility routine.  Given a Python string object, returns its
value or (if not defined) an appropriate description.

(4.0)
*/
static std::string
_Quills_PyStringDesc	(PyObject*		inString)
{
	std::string		result;
	
	
	if ((nullptr != inString) && (nullptr != PyString_AsString(inString)))
	{
		result = PyString_AsString(inString);
	}
	else
	{
		result = "<undefined>";
	}
	return result;
}// _Quills_PyStringDesc


/*!
Utility routine.  Given the Python objects representing the
value and traceback of an exception (both of which might be
nullptr), returns an appropriate description of that exception.

(4.0)
*/
static std::string
_Quills_PyExceptionDesc		(PyObject*		inType,
							 PyObject*		inValue)
{
	std::string		result;
	
	
	// sort out the type
	if (nullptr != inType)
	{
		// this is arbitrary; the more cases that are here, the more “helpful” the message;
		// should follow the inheritance tree documented by "pydoc exceptions"
		if (PyErr_GivenExceptionMatches(inType, PyExc_Exception))
		{
			if (PyErr_GivenExceptionMatches(inType, PyExc_ArithmeticError))
			{
				result = "<ArithmeticError derivative>";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_ImportError))
			{
				result = "ImportError";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_LookupError))
			{
				result = "<LookupError derivative>";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_RuntimeError))
			{
				result = "RuntimeError";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_SyntaxError))
			{
				result = "SyntaxError";
			}
			else
			{
				result = "<Exception derivative>";
			}
		}
		else
		{
			// ???
			result = "<Unknown type>";
		}
		result += ": ";
	}
	else
	{
		result += "<Undefined type>: ";
	}
	
	// sort out the value
	if (nullptr != inValue)
	{
		result += _Quills_PyStringDesc(inValue);
	}
	else
	{
		result += "<no exception details found>";
	}
	
	return result;
}// _Quills_PyExceptionDesc


/*!
Utility routine.  Given a Python object returned by a call to
PyEval_CallObject(), checks to see if it is nullptr and if so,
propagates the exception to the caller; otherwise, does nothing.

The first context argument (and optionally a 2nd string, which
is directly concatenated without extra whitespace) should help
the user to narrow down what the calling routine is.  It is
typical to use PyEval_GetFuncName() as the first context and
PyEval_GetFuncDesc() as the second context, but you may use any
description strings.  The first string should be the most
descriptive and it is mandatory; the 2nd may be nullptr.

A “descriptive” C++ exception is thrown.  If the caller ends
up being Python, SWIG will re-translate this back to raise a
useful Python exception.  If the caller is C++, it can catch
the exception normally.

(4.0)
*/
static void
_Quills_PropagateExceptions		(void*			inResultObject,
								 char const*	inContext1,
								 char const*	inContext2OrNull)
{
	if (nullptr == inResultObject)
	{
		Console_WriteValueCString("Python exception was thrown", inContext1);
		// an exception was thrown; translate it to an appropriate C++ exception
		// (which, actually, will AGAIN be translated back to Python by SWIG, if
		// in fact this was called via Python; otherwise, it can be trapped in C++)
		PyObject*		excType = nullptr;
		PyObject*		excValue = nullptr;
		PyObject*		excTrace = nullptr;
		std::string		excMessage;
		PyErr_Fetch(&excType, &excValue, &excTrace);
		excMessage = "Python raised " + _Quills_PyExceptionDesc(excType, excValue);
		excMessage += "; ";
		excMessage += inContext1;
		if (nullptr != inContext2OrNull)
		{
			excMessage += inContext2OrNull;
		}
		Py_XDECREF(excType); excType = nullptr;
		Py_XDECREF(excValue); excValue = nullptr;
		Py_XDECREF(excTrace); excTrace = nullptr;
		if (false == excMessage.empty()) throw std::runtime_error(excMessage);
	}
}// _Quills_PropagateExceptions
%}
#endif

// enable callbacks that take a long-integer-vector argument and return a map from long-integer to string
#ifdef SWIGPYTHON
%{
static std::map< long, std::string >
CallPythonLongVectorReturnStringByLong	(void*							inPythonFunctionObject,
										 const std::vector< long >&		inLongVector)
{
	std::vector< long >::size_type const	kNumLongs = inLongVector.size();
	PyObject*								pythonDef = nullptr;
	PyObject*								arguments = nullptr;	
	PyObject*								pythonResult = nullptr;
	std::map< long, std::string >			result;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = PyTuple_New(kNumLongs);
	assert(nullptr != arguments);
	for (size_t i = 0; i < kNumLongs; ++i)
	{
		PyObject*	argValue = PyLong_FromLong(inLongVector[i]);
		
		
		if (nullptr == argValue)
		{
			Py_DECREF(arguments); arguments = nullptr;
			throw _Quills_CallbackError("Unable to construct long integer object for argument list", pythonDef);
		}
		PyTuple_SET_ITEM(arguments, i, argValue);
	}
	arguments = Py_BuildValue("(O)", arguments); // produce ((tuple)), as required to pass a single argument of a tuple
	assert(nullptr != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments); arguments = nullptr;
	_Quills_PropagateExceptions(pythonResult, PyEval_GetFuncName(pythonDef), PyEval_GetFuncDesc(pythonDef));
	if (nullptr != pythonResult)
	{
		PyObject*	keys = nullptr;
		Py_ssize_t	keyCount = 0;
		
		
		if (false == PyDict_Check(pythonResult))
		{
			throw _Quills_CallbackError("Dictionary must be returned", pythonDef);
		}
		keys = PyDict_Keys(pythonResult);
		if (false == PyList_CheckExact(keys))
		{
			throw _Quills_CallbackError("Expected dictionary keys to be a list", pythonDef);
		}
		keyCount = PyList_Size(keys);
		for (Py_ssize_t i = 0; i < keyCount; ++i)
		{
			PyObject*	aKey = PyList_GetItem(keys, i);
			PyObject*	stringValue = nullptr;
			
			
			if (false == PyInt_Check(aKey))
			{
				throw _Quills_CallbackError("Returned dictionary key must be an integer", pythonDef);
			}
			stringValue = PyDict_GetItem(pythonResult, aKey);
			if (false == PyString_Check(stringValue))
			{
				throw _Quills_CallbackError("Returned dictionary value must be a string", pythonDef);
			}
			result[PyInt_AsLong(aKey)] = PyString_AsString(stringValue);
		}
	}
	Py_XDECREF(pythonResult); pythonResult = nullptr;
	
	return result;
}
%}
#endif

// enable callbacks that take a single string argument and return nothing
#ifdef SWIGPYTHON
%{
static void
CallPythonStringReturnVoid	(void*	inPythonFunctionObject,
							 char*	inoutString)
{
	PyObject*	pythonDef = nullptr;
	PyObject*	arguments = nullptr;	
	PyObject*	pythonResult = nullptr;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = Py_BuildValue("(s)", inoutString);
	assert(nullptr != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments); arguments = nullptr;
	_Quills_PropagateExceptions(pythonResult, PyEval_GetFuncName(pythonDef), PyEval_GetFuncDesc(pythonDef));
	Py_XDECREF(pythonResult); pythonResult = nullptr;
}
%}
#endif

// enable callbacks that take a single string argument and return a string
#ifdef SWIGPYTHON
%{
// disable for now since nothing technically requires this yet
// (suppresses a warning); re-enable when it is needed later
#if 0
static std::string
CallPythonStringReturnString	(void*	inPythonFunctionObject,
								 char*	inoutString)
{
	PyObject*		pythonDef = nullptr;
	PyObject*		arguments = nullptr;	
	PyObject*		pythonResult = nullptr;
	std::string		result;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = Py_BuildValue("(s)", inoutString);
	assert(nullptr != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments); arguments = nullptr;
	_Quills_PropagateExceptions(pythonResult, PyEval_GetFuncName(pythonDef), PyEval_GetFuncDesc(pythonDef));
	if (nullptr != pythonResult)
	{
		char const*		stringPtr = nullptr;
		
		
		if (false == PyString_CheckExact(pythonResult))
		{
			throw _Quills_CallbackError("String must be returned", pythonDef);
		}
		
		stringPtr = PyString_AsString(pythonResult);
		result = stringPtr;
	}
	Py_XDECREF(pythonResult); pythonResult = nullptr;
	
	return result;
}
#endif
%}
#endif

// enable callbacks that take a string argument and a long-integer argument and return a long-integer pair
#ifdef SWIGPYTHON
%{
static std::pair< long, long >
CallPythonStringLongReturnLongPair	(void*	inPythonFunctionObject,
									 char*	inoutString,
									 long	inLong)
{
	PyObject*				pythonDef = nullptr;
	PyObject*				arguments = nullptr;	
	PyObject*				pythonResult = nullptr;
	std::pair< long, long >	result;
	
	
	result.first = inLong;
	result.second = inLong;
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = Py_BuildValue("(s,l)", inoutString, inLong);
	assert(nullptr != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments); arguments = nullptr;
	_Quills_PropagateExceptions(pythonResult, PyEval_GetFuncName(pythonDef), PyEval_GetFuncDesc(pythonDef));
	if (nullptr != pythonResult)
	{
		PyObject*	item0 = nullptr;
		PyObject*	item1 = nullptr;
		
		
		if (false == PyTuple_CheckExact(pythonResult))
		{
			throw _Quills_CallbackError("Tuple must be returned", pythonDef);
		}
		
		item0 = PyTuple_GetItem(pythonResult, 0);
		if ((nullptr == item0) || (false == PyLong_CheckExact(item0)))
		{
			throw _Quills_CallbackError("First item of returned tuple must be an integer", pythonDef);
		}
		result.first = PyInt_AsLong(item0);
		
		item1 = PyTuple_GetItem(pythonResult, 1);
		if ((nullptr == item1) || (false == PyLong_CheckExact(item1)))
		{
			throw _Quills_CallbackError("Second item of returned tuple must be an integer", pythonDef);
		}
		result.second = PyInt_AsLong(item1);
	}
	Py_XDECREF(pythonResult); pythonResult = nullptr;
	
	return result;
}
%}
#endif

// enable callbacks that take no arguments and return nothing
#ifdef SWIGPYTHON
%{
static void
CallPythonVoidReturnVoid	(void*	inPythonFunctionObject)
{
	PyObject*	pythonDef = nullptr;
	PyObject*	arguments = nullptr;	
	PyObject*	pythonResult = nullptr;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	//arguments = Py_BuildValue("{items}");
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	//Py_DECREF(arguments); arguments = nullptr;
	_Quills_PropagateExceptions(pythonResult, PyEval_GetFuncName(pythonDef), PyEval_GetFuncDesc(pythonDef));
	Py_XDECREF(pythonResult); pythonResult = nullptr;
}
%}
#endif

// NOTE: Quills headers are the only MacTerm headers designed to
// interact with SWIG.  They also define the entire Python API for
// MacTerm in an organized way.  Try not to include other headers here.

%{
#include <QuillsBase.h>
#include <QuillsEvents.h>
#include <QuillsPrefs.h>
#include <QuillsSession.h>
#include <QuillsTerminal.h>
%}

// auto-generate standard first lines for each function docstring
// (basically, the function name, arguments and any return type);
// any additional %feature("docstring", ...) lines will ADD to
// the automatically generated lines caused by the statement below
%feature("autodoc", "0"/* 0 for no parameter types, 1 otherwise */);

// try to generate a single wrapper function when dealing with default arguments
%feature("compactdefaultargs", "1");

// declare C++ APIs that should be exposed to Python
%include <QuillsBase.h>
%include <QuillsEvents.h>
%include <QuillsPrefs.h>
%include <QuillsSession.h>
%include <QuillsTerminal.h>

// BELOW IS REQUIRED NEWLINE TO END FILE
